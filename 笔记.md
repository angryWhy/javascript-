# javascript高级语法

## 01-浏览器执行原理

### 浏览器内核

浏览器引擎也叫，排版引擎，页面渲染引擎，样板引擎

Trident，IE以前用的现在web Bink

webkit，苹果safari，google

Blink,webkit分支

### 浏览器渲染过程 

渲染过程如图：

1.先请求html，HTML Parser执行，将html转成DOM树

2.请求css，使用css parser，生成css规则，将其和DOM树结合在一起

3.render tree（layout）什么位置

4.painting绘制

![](assets/01-01.jpg)

### V8引擎原理

由C++编写，实现ECMAscript和Webassembly

流程：js代码解析--->生成抽象语法树--->ignition（解释器）--->转化成字节码

turboFan：对执行函数多次，会打上印记hot，优化MachineCode

![](assets/QQ截图20220814160440.jpg)

### 代码执行

代码解析，创建全局Object，堆内存

运行代码,创建一个上下文栈（函数调用栈）

全局上下文维护着VO（variable object）（指向GO）

执行代码，例如var a = 9，通过vo找到go修改全局对象，先开始为var a = undefined，然后进行修改，9赋值给a

## 02-函数执行-作用域链

### 函数执行

```javascript
//编译阶段，发现是个函数，堆内存创建这个函数，[[scope chain]] 和函数代码体，将内存地址
//赋值---foo：0xa101
foo()
function foo () {
	console.log("foo run")
}
```

### 查找顺序

作用域链：当前对象的VO+Parent Scope(父级作用域)

Parent Scope(父级作用域)，编译时候确定（！！！）

在当前VO找不到，去上层作用域找

```javascript
//查找顺序，沿着作用域链查找
var name = "wzx"
foo()
function foo () {
	console.log("foo run",name)
}
//寻找name，从函数对象，VO里面去寻找也就是AO，作用域链
//执行完成，从函数调用栈移除
```

#### 多层嵌套函数

函数嵌套函数，如果该开始不立即执行，则不需要编译，做预编译

```javascript
foo(123)
function foo (num) {
    var name = "wzx"
    var sex = "nan"
	function bar () {
		console.log("bar执行")
	}
    bar()
}
//foo的VO对象 num,name,sex,函数参数属于自己的vo对象
//执行顺序，外层函数执行，压入栈
//内部函数执行完，依次弹出
```

#### 作用域链

```javascript
var message = "window"
function foo() {
    var message = "foo"
    bar()
}
function bar() {
    console.log(message);
}
foo()
//执行创建全局对象
message：undefined
foo：0Xa00
//foo对象
message：undefined
bar：0xb10
//bar对象


```

### 作用域提升面试题

例1

```javascript
var n =100 
//定义位置，父级作用域为全局
function foo (){
	n=200
}
foo()
console.log(n)
//200
```

例2

```javascript
function foo (){
    //undefined,自己存在
	console.log(n)
	var n = 200
    //200
	console.log(n)
}
var n = 100
foo()
```

例3

```javascript
var n=100
function foo1() {
    //自己不存在，找全局的
	console.log(n)
}
function foo2(){
	var n =200
    //自己的
	console.log(n)
    foo1()
}
foo1()
foo2()
//全局
console.log(n)// 100
```

例4

```javascript
var a = 100
function foo (){
    //undefined
	console.log(a)
    //运行时return
	return
	var a= 200
}
```

例5

```javascript
function foo10 (){
	var m = 100
}
foo10()
//找不到
console.log(m)
```

例5

```javascript
function foo11(){
	var a = b = 10
	//相当于
	var a = 10
	b=10
}
```

### 内存管理

1.申请分配内存

2.使用分配内存，存储对象

3.释放内存

基本数据类型：栈空间

引用类型：内存堆

## 03-闭包

### 定义

函数+访问的自由变量

1.闭包，又称词法闭包(Lexical Closure )或函数闭包( function closures ) 

2.是在支持头等函数的编程语言中，实现词法绑定的一种技术;

3.闭包在实现上是一个结构体，它存储了一个函数和一个关联的环境（相当于一个符号查找表）;

4.闭包跟函数最大的区别在于，当捕捉闭包的时候，它的自由变量会在补充时被确定，这样即使脱离了捕捉时的上下文，它也能照常运行;

### 案例

```javascript
function foo() {
    var name = "a"
    function bar() {
        console.log("bar", name)
    }
    return bar
}
var fn = foo()
fn

//开始执行
//创建全局GO，有名变量赋值undefined，函数分配内存地址
//从上往下执行
//foo函数执行
//name 赋值，bar函数创建对象
//return，foo函数代码体执行完毕，从函数调用栈弹出
//fn赋值为 bar函数
//bar函数执行
//bar函数找到name，通过作用域链，找到定义上下文的name为foo的name

//本来foo函数执行完了销毁，但是没有销毁，仍能访问里面的变量
```

#### 内存泄漏案例

```javascript
function foo (){
	var name= "wzx"
	var sex = "men"
	function bar (){
		console.log(name,sex)
	}
	return bar
}
var fn = foo()
fn()
//全局对象属性fn引用着bar函数，bar函数引用着foo函数对象
//解决foo=null，fn=null
```

![](assets/闭包.jpg)

## 04-this指向 

全局作用域指向window，node环境，指向{}

this与调用位置，调用方式有关，运行时绑定

### 规则一：默认绑定

独立函数调用，函数没有绑定到某个对象上调用

```javascript
//---------1.
function foo() {
    console.log(this);
}
function bar() {
    console.log(this);
}
function zoo() {
    bar()
}
zoo()

//---------2.
var obj = {
    say() {
        console.log(this);
    },
    he: zoo
}
var fn = obj.say()
fn()


//---------3
function aaa() {
    function haha() {
        console.log(this);
    }
    return haha
}
var bbb = aaa()
bbb()
```

### 规则二：隐式绑定

某个对象发起调用，调用位置，是通过某个对象发起的函数调用

对象会被自动的被js引擎绑定到函数的this上

前提:调用对象内部必须有一个函数的引用(例如属性)

```javascript
//---------1.
function foo (){
	console.log(this)
}

//foo()
//独立函数调用


var obj = {
	name:"obj"
    foo:foo
}
//隐式绑定，绑定到obj上
obj.foo()

//---------2.
var obj = {
	name:"obj1",
    foo(){
    	console.log(this.name)
    }
}
var obj2 = {
	name:"obj2",
    bar:obj1.foo
}
obj2.bar()
```

### 规则三：显示绑定

不希望函数在这个对象上，但是希望是这个对象调用

call,apply,bind

明确指定调用对象

```javascript
//call,参数列表
//apply,数组
```

```javascript
//---------1.
function foo () {
	console.log("wz")
}

//直接调用不绑定，指向window
foo.call()---foo.apply()


//---------2.
function foo () {
	console.log(this)
}
foo.call("str")
foo.call(obj)

//---------call与apply区别.
function foo (a,b) {
	console.log(this,a+b)
}
foo.call(obj,20,30)
foo.apply(obj,[20,30])


//---------bind.不用多次绑定
function bar () {
	console.log(this)
}
var fn = bar.bind("haha")
fn()//"haha"
fn()//"haha"
```

### 规则四：new绑定

```javascript
//我们通过一个new关键字调用一个函数时(构造器)，这个时候this是在调用这个构造器时创建出来的对象
//this = 创建出来的对象
//这个绑定过程就是new绑定
```

```javascript
function person(name, age) {
    this.name = name
    this.age = age
    return this
}
var p = new person()

//
 var obj = {
            name:"a",
            foo:function (){
                var name = "b"
                this.name = "c"
                console.log(this,this.name)
            }
        }
        new obj.foo()//"c"
```

### this优先级

默认绑定规则最低

显示绑定高于隐式绑定

new 绑定高于隐式绑定

new --->显示--->隐式--->默认 

```javascript
//显示绑定高于隐式绑定
function foo (){
	console.log(this)
}
var obj = {
	bar:foo.bind("aaa")
}
obj.foo()//"aaa"

//new高于隐式绑定

```

### 箭头函数

不绑定this，根据外层作用域决定this

```javascript
//普通匿名函数
var obj = {
	arr:[]
    sum(){
    var _this = this
		setTimieout(function(){
		_this.arr.push(1)
		},1000)
	}
}

//箭头函数
var obj = {
	arr:[]
    sum(){
    var _this = this
		setTimieout(()=>{
		this.arr.push(1)
		},1000)
	}
}
```

### 面试题（一）

```javascript
var name = "window";

var person = {
  name: "person",
  sayName: function () {
    console.log(this.name);
  }
};

function sayName() {
  var sss = person.sayName;
  sss(); //window，独立默认调用
  person.sayName();//隐式，对象调用
  (person.sayName)();//隐式，对象调用
  (b = person.sayName)(); //赋值表达式，window
}

sayName();
```

### 面试题（二）

```javascript
var name = 'window'

var person1 = {
    name: 'person1',
    foo1: function () {
        console.log(this.name)
    },
    foo2: () => console.log(this.name),
    foo3: function () {
        return function () {
            console.log(this.name)
        }
    },
    foo4: function () {
        return () => {
            console.log(this.name)
        }
    }
}

var person2 = { name: 'person2' }

 person1.foo1(); //隐式，对象调用,person1
 person1.foo1.call(person2); //显示绑定，person2

 person1.foo2(); //window，对象没作用域
 person1.foo2.call(person2); //window，对象没作用域

 person1.foo3()();//独立函数调用，person1.foo3()拿到结果
 person1.foo3.call(person2)(); //window，独立函数调用
 person1.foo3().call(person2); //person2，显示绑定

 person1.foo4()(); //箭头函数不绑定this，person1
 person1.foo4.call(person2)();//上层函数被绑定一个person2，箭头函数继承person2
 person1.foo4().call(person2);//不绑定，person1
```

### 面试题（三）

```javascript
var name = 'window'

function Person (name) {
  this.name = name
  this.foo1 = function () {
    console.log(this.name)
  },
  this.foo2 = () => console.log(this.name),
  this.foo3 = function () {
    return function () {
      console.log(this.name)
    }
  },
  this.foo4 = function () {
    return () => {
      console.log(this.name)
    }
  }
}

var person1 = new Person('person1')
var person2 = new Person('person2')

person1.foo1() //person1
person1.foo1.call(person2)// person2

person1.foo2() //person1
person1.foo2.call(person2)//person1,上层

person1.foo3()() //window
person1.foo3.call(person2)()//window
person1.foo3().call(person2) //person2

person1.foo4()() //person1，上层
person1.foo4.call(person2)() //上层是person2，
person1.foo4().call(person2) //上层person1


var obj = {
  name: "obj",
  foo: function() {

  }
}
```

### 面试题（四）

```javascript
var name = 'window'

function Person (name) {
  this.name = name
  this.obj = {
    name: 'obj',
    foo1: function () {
      return function () {
        console.log(this.name)
      }
    },
    foo2: function () {
      return () => {
        console.log(this.name)
      }
    }
  }
}

var person1 = new Person('person1')
var person2 = new Person('person2')

person1.obj.foo1()() 
person1.obj.foo1.call(person2)() 
person1.obj.foo1().call(person2) 

person1.obj.foo2()() 
person1.obj.foo2.call(person2)() 
person1.obj.foo2().call(person2) 

 

 var obj = {
   name: "obj",
   foo: function() {
     // 上层作用域是全局
   }
 }

 function Student() {
   this.foo = function() {

   }
 }
```

## 05-apply，call，bind实现

### call方法

```javascript
Function.prototype.calldemo = function (thisArg, ...params) {
    //this，指向当前函数
    var fn = this
    //自己调用，执行，相当于没传参数
    fn()
    thisArg = thisArg ? Object(thisArg) : window
    //传入要绑定对象，上面添加属性为fn（当前的fn）
    thisArg.thisfn = fn
    //隐式绑定，参数调用这个fn
    var res = thisArg.thisfn(...params)
    return res
}
```

### apply方法

```javascript
Function.prototype.applydemo = function (thisArg, params) {
    //this，指向当前函数
    var fn = this
    //自己调用，执行，相当于没传参数
    fn()

    thisArg = thisArg ? Object(thisArg) : window
    //传入要绑定对象，上面添加属性为fn（当前的fn）
    thisArg.thisfn = fn
    //隐式绑定，参数调用这个fn
    params = params || []
    var res = thisArg.thisfn(...params)
    return res
}
```

### bind方法

```
Function.prototype.bindDemo = function (thisArg, ...argwarap) {
    var fn = this
    function proxyFn(...args) {
        thisArg.fn = fn
        var result = thisArg.fn(...argwarap, ...args)
        return result
    }
    return proxyFn
}
```

### arguments对象

```javascript
1.arguments.length			//参数长度
2.arguments[1]			    //根据索引获取值
3.arguments.callee			//获取当前函数的参数
```

## 06-纯函数、柯里化

#### 纯函数

1.确定的输入，一定会产生确定的输出

2.不会产生副作用（修改全局变量，修改参数，）

#### 柯里化

概念:接受多个参数的函数，转化为接受一个参数的结果

```javascript
简单例子：
function fn (a) {
	return (b) =>{
		return a+b
	}
}
```

## 07-面向对象

概念:属性的无序集合 	-key是一个标识符的名称，value是任意类型

#### 属性描述符

```javascript
const obj = {
    name: "hello"
}
//单个属性
Object.defineProperty(obj, "name", {
    //可删除，可修改？？？
    configurable: true,
    //值
    value: "world",
    //是否枚举
    enumerable: true,
    //是否可修改
    writable: true,
    get: function () {
        return "getter方法"
    },
    set: function () {
        this.name = "setter方法"
    }
})
//多个属性
Object.defineProperty(obj,{
    name:{
    	writable: true,
    },
    age:{
    	  value: "world",
    }
})
```

```javascript
//阻止对象扩展，添加新属性
Object.preventExtensions(obj)
//禁止对象配置/删除属性
Object.seal(obj)
//不可修改
Object.freeze(obj)
```

#### new操作符

```javascript
function person ( name ) {
	this.name = name
}
const obj = new person()
```

## 08-原型和原型链

#### 原型

每个对象都有一个[[prototype]]（原型）

```javascript
//创建一个对象，并且浏览器添加一个原型对象赋值为{}
var obj = {name:"hello",__proto__:{}}
```

##### 原型作用

```javascript
//当我们从对象中获取值，触发get操作
//1.先从当前自身上找，找到就使用
//2.没找到，从原型上去找
var obj = {
	name:"gaga"
}
//没有age
console.log(obj.age)//err
//原型上添加
obj.__proto__.age = 20
console.log(obj.age)//ok
```

### 函数的原型

```javascript
//函数除了__proto__（也就是[[prototype]]===隐式原型），还有prototype（显示原型）
function foo (){
	
}
console.log(foo.prototype)//{}
```

#### __proto与prototype关系

```javascript
//内部操作,new关键字
function foo () {
	var obj = {}
    this = {}
    this.__proto__ = foo.prototype
}
const p1 = new foo()
const p2 = new foo()
p1.__proto__ === foo.prototype
p2.__proto__ === foo.prototype
```

#### 函数的构造函数

```javascript
function bar () {
	
}
const p1 = new Bar()
const p2 = new Bar()
```

![](assets/obj.png)

#### 属性查找顺序

```javascript
function bar () {}
const p1 = new Bar()
p1.name
//自身属性上找，未找到，原型去寻找

//方法一：
p1.__proto__.name="hello"
//相当于在p1的__proto__，上添加name属性，并且指向prototype上也有name属性
```

#### 原型对象

每个函数的prototype都有一个属性constructor

```javascript
function foo () {}
foo.prototype.constructor ===（指向函数本身） foo
```

#### 重写prototype

```javascript
function foo () {}
foo.prototype = {
	//指向函数本身
	constructor:foo,
	name:"hell",
    sex:"men"
}
//使constructor不可枚举
Object.defineProperty(foo.prototype,"constructor",{
	enumerable:false,
    configurable:true
})
```

### 原型链

![](assets/原型链.jpg)

```javascript
var obj = {
    name: "why",
    age: 18
}

//[[get操作]]
//当前对象查找属性
//没找到，从原型上去找,原型链__proto__

obj.__proto__ = {}
console.log(obj.address);

//原型对象上也有原型对象

//也有对应的原型对象
// obj.__proto__ = {
//     __proto__: {}
// }
obj.__proto__.__proto__ = {
    sex: "men"
}
console.log(obj.sex);
```

##### 顶层原型

从Object上创建的对象原型都是[Object:null prototype] { }

[Object:null prototype] { }对象特殊点

1、该对象上有原型属性，但是指向为null

2、该对象上有很多的默认方法

```javascript
//顶层原型Object
var obj = new Object()
function foo (){}
var f1 = new foo()

//1、创建内存区域
//2、创建空对象，将其赋值给this
//3、空对象的__proto__ = Object.prototype
//4、返回这个对象

var obj = {
	name:"why",
    age:18
}
var obj2 = {
 address:"hell"
}
obj.__proto__ = obj2

//console.log(obj.address)
//以下查找顺序
```

![](assets/原型链1.jpg)
